
### 1. Membership Operators (`in`, `not in`)

These operators check for the existence of an item without needing a manual loop.

```python
def hasSecretNumber(L, target):
    # 'in' scans the list and returns True if target is found
    if target in L:
        return "Found it!"
    # If the 'if' fails, the target is missing
    return "Not there."

L = [10, 20, 42]
hasSecretNumber(L, 20) # Returns "Found it!"

```

---

### 2. Mutating Patterns (In-Place Changes)

Use a `while` loop when deleting items from the original list. If you use a `for` loop, you will skip items because the list "shrinks" while you are moving through it.

```python
def mutatingRemove(L, target):
    currentIndex = 0

    # Use 'while' because the length of L changes when we pop items
    while currentIndex < len(L):
        if L[currentIndex] == target:
            # .pop(i) removes the item and shifts everything else left
            L.pop(currentIndex)
            # DO NOT increment currentIndex here; the "next" item 
            # just slides into the current position.
        else:
            # Only move forward if we didn't remove anything
            currentIndex += 1

L = [1, 2, 3, 2, 4]
mutatingRemove(L, 2)
print(L) # L is changed to [1, 3, 4]

```

---

### 3. Non-Mutating Patterns (Creating New Lists)

This is generally safer. We create a `result` list and fill it, leaving the original data untouched.

```python
def nonMutateRemove(L, target):
    resultList = [] # Start with a clean, empty list
    for value in L:
        # Check every value in the original list
        if value != target:
            # Add it to the new list only if it's NOT the target
            resultList.append(value)
    return resultList # Return the new list; L remains original

L = [1, 2, 3, 2, 4]
M = nonMutateRemove(L, 2)
# L is still [1, 2, 3, 2, 4]
# M is [1, 3, 4]

```

---

### 4. Slicing (`L[start:stop]`)

Slicing creates a **new copy** of a section of a list.

```python
def getHalves(L):
    # //2 gets the middle index (even for odd-length lists)
    midIndex = len(L) // 2
    # L[:midIndex] goes from index 0 up to (but excluding) midIndex
    firstHalf = L[:midIndex]
    # L[midIndex:] goes from midIndex to the very end
    secondHalf = L[midIndex:]
    return firstHalf, secondHalf

# Usage: getHalves([1, 2, 3, 4, 5]) -> ([1, 2], [3, 4, 5])

```

---

### 5. Modulo & Math (`%`, `//`)

* `%` (Modulo) gives the **remainder**.
* `//` (Floor Division) gives the **whole number quotient**.

```python
def mathDemo(n):
    # If a number divided by 2 has 0 remainder, it's even
    isEven = (n % 2 == 0)
    # Find how many times 2 goes into n fully
    halfIndex = n // 2 
    return isEven, halfIndex

```

---

### 6. Negative Indexing

Python lets you count from the end of a list using negative numbers.

```python
def getEnds(L):
    # -1 is always the very last item
    lastItem = L[-1]
    # -2 is the second to last item
    secondToLast = L[-2]
    return lastItem, secondToLast

```

---

### 7. List Operations Reference

| Operation | Type | Camel Case Example | Purpose |
| --- | --- | --- | --- |
| **Append** | Mutating | `myList.append(10)` | Adds an item to the end of the existing list. |
| **Pop** | Mutating | `myList.pop(0)` | Removes the item at index 0 and shifts the rest. |
| **Swap** | Mutating | `L[i], L[j] = L[j], L[i]` | Swaps two values in place without a third variable. |
| **Combine** | Non-Mutating | `newList = listA + listB` | Creates a new list by joining two others. |
| **Repeat** | Non-Mutating | `zeros = [0] * 5` | Creates a list `[0, 0, 0, 0, 0]`. |


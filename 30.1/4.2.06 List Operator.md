# 4.2.06  List Operators

## Non-Mutating List Operators

**Non-mutating** operators **do not change the original list**. Instead, they compute and return a **new list** (or a Boolean value)


### TL;DR 
(totally not stolen from cheat gpt... not at all)

| Operator | Mutates? | Returns New List? | Notes |
| :---: | :---: | :---: | :--- |
| `L * n` | ❌ | ✅ | Creates a new repeated list. |
| `L += [...]` | ✅ | ❌ | **Mutates** the original list (uses `L.extend()`). |
| `L = L * n` | ❌ | ✅ | **Replaces** the variable $L$ with a new list. |
| `L + M` | ❌ | ✅ | Creates a new concatenated list. |
| `copy.copy(L)` | ❌ | ✅ | Safest, standard way to create a shallow copy. |
| `L[:]` | ❌ | ✅ | Slice operator creates a shallow copy. |




---

### Comparison Operators (`==`, `!=`, `<`, `>`, etc.)


| Operator | Meaning | Example | Result |
| :---: | :--- | :--- | :---: |
| `==` | Equal (same contents) | `[1, 2] == [1, 2]` | `True` |
| `!=` | Not equal | `[1, 2] != [1, 3]` | `True` |
| `<` | Less than | `['d','o','g'] < ['d','u','c','k']` | `True` |
| `>` | Greater than | `[3, 4] > [3, 2]` | `True` |

#### Rules for Ordering (`<, <=, >, >=`)

1.  **Index by Index:** Values are compared at each index until the first differing element is found. The list with the smaller element is the smaller list.
2.  **Prefix:** If one list is a **prefix** of the other (e.g., `[1, 2]` vs. `[1, 2, 3]`), the **shorter** list is considered **smaller**.
    Example: $\text{"dog"} < \text{"duck"}$ and $\text{"dog"} < \text{"dogs"}$

    ```python
    print([1, 2, 3] == [1, 2, 3, 4])     # False
    print([1, 2, 3, 4] >= [1, 2, 3, 4])  # True
    print([1, 2, 3] <= [1, 2, 3, 4])     # True (Shorter prefix is smaller/equal)
    print([1, 3, 4] <= [1, 2, 3, 4])     # False (3 is not <= 2 at index 1)
    print([1, 3, 4] >= [1, 2, 3, 4])     # True (3 is >= 2 at index 1)
    ```

-----

### Checkpoint

Assume we have the following lists:

```python
L = [2, 4, 6, 8]
N = [0, 1, 2, 3]
M = [2, 5, 0, 0]

```

**Which of the following comparisons evaluates to `True`?**

* A. `L <= N`
* B. `L < M`
* C. `N > M`
* D. `L == [2, 4, 6]`

  <details>
  <summary><b>Answer</b></summary>
  <blockquote>

  **B**
  
  Python compares index-by-index. 
  
  At index `[0]`, both lists have `2` (a tie). 
  At index `[1]`, `L` has `4` and `M` has `5`. 
  
  Since , the comparison is finished and returns `True`.
  
  * **Why A is False:** At index `[0]`,  is `False`.
  * **Why C is False:** At index `[0]`,  is `False`.
  * **Why D is False:** Even though the first three elements match, the lengths are different, so they are not equal.

  </blockquote>
  </details>


> [!NOTE]
> **Dictionary Order:** Lists are compared just like words in a dictionary. Python looks at the first "letter" (index 0). If they are the same, it moves to the second. As soon as it finds a difference, it stops and gives you the result

-----

### Indexing and Slicing

* Indexing (`L[i]`) and slicing (`L[start:end]`) are **non-mutating**. Slicing always returns a **new list** object.

  ```python
  L = [10, 20, 30]
  copy = L[:]  # makes a NEW list
  print(copy is L)  # False (They are separate objects)
  ```

-----

### Membership Operators (`in` and `not in`)

* Checks if an **element** exists in a list.

  ```python
  1 in [1, 2, 1]      # True
  'ab' in ['a', 'ab'] # True
  [2, 1] in [1, 2, 1] # False (Checks for the element '[2, 1]', not the sublist)
  ```


> [!IMPORTANT] 
> The `in` Operator (List Membership)
> 
> 1.  **Element-Level Check:** The `in` operator checks if an item exists as a **single, individual element** within the list (exact value match).
> 
> 2.  **Applies to Nested Elements:** If the list contains other data structures (like nested lists), the check must match that full structure object.
>     * Example: `[20, 30] in [10, [20, 30], 40]` is **True**.
> 3.  The `in` operator checks for **elements**, not **sublists**. It does not look for consecutive sequences.
    * Example: `[2, 3] in [1, 2, 3]` is **False**.
> 


---

### Concatenation (`+`) and Repetition (`*`)

Both operators are **non-mutating** and always create **new lists**
* `*` Repeats the List:
  ```python
  L = [1, 2, 3]
  M = L * 2
  # L:  [1, 2, 3]
  # M:  [1, 2, 3, 1, 2, 3]
  # L is M: False (M is a new list)
  ```

* `+` Concatenates Lists:

  ```python
  L = [1, 2]
  M = L + [3, 4]
  # L → [1, 2]
  # M → [1, 2, 3, 4]
  ```

This is why `L + []` and `L * 1` are simple ways to create a copy of `L`.

---

## Mutating List Operators

**Mutating** operators **change** the original list object in memory.

### Augmented Assignment (`+=` and `*=`)
* When used with lists, these operators usually mutate the original list.

  ```python
  import copy
  L = [1, 2]
  M = L
  N = copy.copy(L) # N is a separate copy

  L += [3]  # Uses the list's extend logic (mutating)
  L *= 2    # Mutates L in place

  print(L)  # [1, 2, 3, 1, 2, 3]
  print(M)  # [1, 2, 3, 1, 2, 3] (Mutated because it's an alias of L)
  print(N)  # [1, 2]             (Not affected because it's a copy)
  ```

  * `L += [3]` and `L *= 5` **mutate** the list referred to by L.
  * `L = L * 5` does **not** mutate; it assigns a new, different list to the variable L.

-----

### Checkpoint

**Which of the following operations actually mutates the original list object `L`?**

* A. `L = L * 5`
* B. `L *= 5`
* C. `M = copy.copy(L)`
* D. `M = L + [3]`

  <details>
  <summary><b>Answer</b></summary>
  <blockquote>

  **B.**


  * **B (`L *= 5`):** This is a special **in-place** operator for lists. It reaches into the existing memory where `L` lives and adds the new items directly to it.
  * **A (`L = L * 5`):** This looks similar, but it calculates a brand-new list on the right side first, and then reassigns the variable name `L` to point to that new object. The original list is left unchanged (until it is deleted from memory).
  * **C (`M = copy.copy(L)`):** This specifically creates a duplicate so that any changes made to `M` will not affect `L`.
  * **D (`M = L + [3]`):** The `+` operator always creates a **new list** result. Since we assign that result to `M`, the original `L` remains exactly as it was.

  </blockquote>
  </details>

---

> [!NOTE]
> **TLDR:** Any time you see `L = ...`, you are likely **reassigning** the name to a new object. Methods like `.append()`, `.pop()`, or the `L *=` operator are the ones that **mutate** the original object.



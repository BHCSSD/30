# 4.2.7  List-Related Builtin Functions

All of these functions are **non-mutating**. They perform operations and return new values without changing the original list.

---

## `list()` and `type()`

* `list()` creates a **new empty list**.
* If passed a sequence (like a string or range), it "unpacks" it into a list.
  * **Note:** `list(L)` creates a **shallow copy** of list `L`. While `copy.copy(L)` is explicit, `list(L)` is a very common Pythonic way to clone a list.
  * I want you to ALWAYS use  `copy.copy(L)` it is best to always be explicit

  ```python
  # Conversion
  chars = list('abc')  # ['a', 'b', 'c']

  # Type Checking
  L = [1, 2, 3]
  print(type(L) == list)  # True

  ```

> [!IMPORTANT]
> Always compare the data types using the class name `list`, not the string `'list'`.
> * `print(type(L) == list)` is good
> * `print(type(L) == "list")` is antigood

### **Checkpoint**

1. If `L` is a list, which of the following is **False**?

    <details>
    <summary>1. <code>type(L) == list</code></summary>
    <blockquote>
    <b>True.</b> The <code>type()</code> function returns the class object, and <code>list</code> is the name of that class.
    </blockquote>
    </details>

    <details>
    <summary>2. <code>type(L) == 'list'</code></summary>
    <blockquote>
    <b>FALSE.</b> <code>type(L)</code> returns a <b>type object</b> (<code>&lt;class 'list'&gt;</code>), not a <b>string</b>. Comparing a type to the word <code>'list'</code> will always be False.
    </blockquote>
    </details>

    <details>
    <summary>3. <code>type(L) == type(list())</code></summary>
    <blockquote>
    <b>True.</b> Both <code>L</code> and <code>list()</code> are lists, so their types are identical.
    </blockquote>
    </details>

    <details>
    <summary>4. <code>type(type(L)) == type</code></summary>
    <blockquote>
    <b>True.</b> In Python, classes (like <code>list</code>) are themselves objects created from the <code>type</code> class. It's "types all the way down!"
    </blockquote>
    </details>


> [!TIP]
> When you are coding and want to check if something is a list, the most "Pythonic" way to do it isn't actually `type(L) == list`. Instead, use the **`isinstance()`** function:
> 
> ```python
> isinstance(L, list)  
> 
> ```

---

## `len()`

* `len(L)` returns the **total count** of elements.
* **Index Range:**  to .

  ```python
  L = [10, 20, 30]
  print(len(L))  # 3

  ```

---

## `min()`, `max()`,  `sum()`

| Function | Result | Requirement |
| --- | --- | --- |
| `min(L)` | Smallest value | Elements must be comparable |
| `max(L)` | Largest value | Elements must be comparable |
| `sum(L)` | Total sum | Elements must be **numeric** |

```python
nums = [2, 1, 3]
print(min(nums))  # 1
print(max(nums))  # 3
print(sum(nums))  # 6

words = ['apple', 'zebra', 'banana']
print(max(words)) # 'zebra' (easy way to make alphabetical)

```

> [!WARNING]
> Mixing types (e.g., `[1, 'two']`) will result in a `TypeError` because Python doesn't know how to compare numbers to strings.

---

## `sorted()`

`sorted(L)` creates a **new** sorted list. It does not touch the original.

```python
L = [8, 3, 2]
M = sorted(L)
R = sorted(L, reverse=True)

print(L) # [8, 3, 2] (unchanged)
print(M) # [2, 3, 8]
print(R) # [8, 3, 2]

```
> [!NOTE]
> **`.sort()` vs `sorted()`:**
> 
> * `.sort()` changes the existing list and returns `None`. 
> * `sorted()` leaves the list alone and returns a brand-new sorted copy.
>   * If you want to keep your original data, always use `sorted()`.

---

## `reversed()`

Unlike `sorted()`, `reversed()` returns a **reverse iterator** (an object that remembers the way back) rather than a list.

```python
L = [1, 2, 3]
rev_obj = reversed(L) 
print(rev_obj)        # <list_reverseiterator object...>
print(list(rev_obj))  # [3, 2, 1]

```

**Efficiency Tip:** Use `reversed()` in a `for` loop to avoid the memory cost of creating a whole new list.

---

### **Checkpoint**

2. If for list `L` all the following are true:

  * `min(L) == 0`
  * `sum(L) == 1`
  * `len(L) == 2`

  * Which of the following must be **False**?

    <details>
    <summary>1. <code>L</code> contains no negative values</summary>
    <blockquote>
    <b>Possible (True).</b> If the list is <code>[0, 1]</code>, there are no negative values. This satisfies all conditions.
    </blockquote>
    </details>

    <details>
    <summary>2. <code>L</code> contains no odd values</summary>
    <blockquote>
    <b>FALSE.</b> To have a <code>sum(L)</code> of 1 with only two elements (one of which is 0), the other element <b>must</b> be 1. Since 1 is an odd number, the statement "no odd values" is impossible.
    </blockquote>
    </details>

    <details>
    <summary>3. <code>max(L) == 1</code></summary>
    <blockquote>
    <b>True.</b> In a two-item list where the minimum is 0 and the sum is 1, the values must be 0 and 1. Therefore, the maximum is 1.
    </blockquote>
    </details>

---


3. Which list `L` will result in `L == N` being **False**?

    ```python
    M = sorted(L, reverse=True) # Sorts descending
    N = list(reversed(M))       # Reverses that to make it ascending
    print('yes' if L == N else 'no')

    ```

    <details>
    <summary><b>Answer</b></summary>
    <blockquote>
    Any list <code>L</code> that is <b>not already sorted</b> in ascending order will print <b>'no'</b>.
 
    If we use <code>L = [3, 1, 2]</code>:
    <ol>
    <li><b>M:</b> <code>sorted(L, reverse=True)</code> creates a new list sorted <i>descending</i>: <code>[3, 2, 1]</code>.</li>
    <li><b>N:</b> <code>list(reversed(M))</code> takes that descending list and flips it, making it <i>ascending</i>: <code>[1, 2, 3]</code>.</li>
    <li><b>The Test:</b> Does <code>[3, 1, 2] == [1, 2, 3]</code>? <b>False.</b></li>
    </ol>
    The only way <code>L == N</code> is True is if <code>L</code> was already sorted from the start (like <code>[1, 2, 3]</code> or <code>[5]</code>).
    </blockquote>
    </details>

---

> [!NOTE]
> Sorting a list descending and then reversing it is mathematically the same as just sorting it normally:
> 
> 8 `list(reversed(sorted(L, reverse=True)))` is equal to `sorted(L)`.

----

> [!NOTE]
> **TLDR:** 
>  Use `sorted()` and `list(reversed())` when you want to keep your original list safe.
> * If you use `.sort()`, the original order is gone forever
> 
> 
> | Function | Returns | Purpose |
> | --- | --- | --- |
> | `list(seq)` | `list` | Converts a sequence (string, tuple) into a list |
> | `len(L)` | `int` | Returns the total count of elements |
> | `sum(L)` | `int` / `float` | Adds all numeric elements together |
> | `sorted(L)` | `list` | Returns a **new** list sorted ascending |
> | `reversed(L)` | `iterator` | Returns a "pointer" to read the list backwards |
> 
> ---
>
> **Method vs. Function:**
> * `L.sort()` is a **method** (modifies the list in place).
> * `sorted(L)` is a **function** (creates a copy).



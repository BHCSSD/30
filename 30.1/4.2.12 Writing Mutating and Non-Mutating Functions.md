# **4.2.12 Writing Mutating and Non-Mutating Functions**

## **Main Idea**

* When writing a function that takes a **list**, you must decide if it is **mutating** or **non-mutating**
    * **Mutating:** Modifies the original list object passed in as an argument
    * **Non-mutating:** Leaves the original list exactly as it was and usually returns a new value or list

---

## **General Rules**

* **Default to Non-Mutating:** Unless a problem specifically asks to change a list, assume the function should be non-mutating
* **Expectation:** It is considered a bug to change a list if the user doesn't expect it
    * `median(L)` **Non-mutating.** (You shouldn't scramble a student's grades just to find the middle one)
    * `removeAll(L, v)` **Mutating.** (The name implies the list itself will be cleaned)

---

## **Mutating Example**

```python
# Mutating version: changes L directly
def removeAll(L, v):
    i = 0
    while i < len(L):
        if L[i] == v:
            L.pop(i) # Changes the original L
        else:
            i += 1

L = [1, 2, 3, 2, 3, 2, 4]
removeAll(L, 2)
print(L)  # [1, 3, 3, 4]

```

> [!NOTE]
> * Uses methods like `.pop()`, `.append()`, or `.sort()` directly on the parameter `L`
> * **Returns None:**
>    * Most mutating functions don't need to return the list because the caller already has access to the modified version

---

## **Non-Mutating Example**

```python
# Non-mutating version: builds and returns a new list
def removeAll(L, v):
    result = [] #make a brand new list IMPORTANT
    for value in L:
        if value != v:
            result.append(value)
    return result #Return the new version

L = [1, 2, 3, 2, 3, 2, 4]
M = removeAll(L, 2)
print(L)  # [1, 2, 3, 2, 3, 2, 4] (Unchanged!)
print(M)  # [1, 3, 3, 4] (The result)

```

> [!NOTE]
> * Creates a **local list** (`result`) to store values.
> * The original list `L` is never touched.
> * **Must return** the result so the caller can use it.


> [!IMPORTANT]
> A function is still "non-mutating" even if it uses `.append()` or `.sort()` as long as those methods are called on **newly created local lists** and not the original parameter list.
> *aka it is used on a `copy.copy` made insdie a your function.

---

## Checkpoint

**Which of the following is False?**

* A. A non-mutating function is only not allowed to mutate its parameters. It is fine to create new lists in local variables and mutate those.
* B. Unless we specifically say that a function is mutating, then by default, it must be non-mutating.
* C. All mutating functions return None because they directly change their parameters.
* D. When you write a function that takes a list, you have to decide whether or not your function is mutating.

    <details>
    <summary><b>Click to reveal answer</b></summary>
    <blockquote>
    <b>C. All mutating functions return None because they directly change their parameters.</b>

    While <i>most</i> mutating functions return <code>None</code> (like <code>.sort()</code> or <code>.append()</code>), it is not a strict rule. Some mutating functions, like <code>.pop()</code>, mutate the list <b>and</b> return a value at the same time.
    </blockquote>
    </details>


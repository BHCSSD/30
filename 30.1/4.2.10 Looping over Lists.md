# **4.2.10 Looping Over Lists**

* Looping is how we visit every item in a list
    * how you loop depends on whether you just want to see the data or if you need to change it

---

## Looping Over Values vs. Indexes

## Two Types of For Loops

### 1. Looping by Index  (for i in range() )

* You loop over the **indexes** using `range( len(L) )`  
   * Use this when you need to know the **position** of the item or if you need to modify the list at a specific spot
  ```python
  L = [42, True, 'wahoo']
  for i in range( len(L) ):
      print(L[i])
  # Output:
  # 42
  # True
  # wahoo
  ```

### 2. Looping by Value (for each in)
* You loop **directly through the values** themselves
   * Use this when you only care about the items themselves. It's cleaner and easier to read

  ```python
  L = [42, True, 'wahoo']
  for value in L:
      print(value)
  # Output:
  # 42
  # True
  # wahoo
  ```
   

---

## The Mutation Hazard

Modifying a list (adding or removing items) while looping over it with a `for` loop is a classic trap. It causes bugs because the loop "roadmap" doesn't update when the list changes.

* **The "Skipped Item" Problem**
   * When you `pop(i)`, every element to the right slides over to fill the gap
   * If your loop counter `i` moves forward anyway, you will jump right over the element that just slid into your current position

### The Solution: The `while` Loop
* A `while` loop allows you to control exactly when the index `i` moves forward

   ```python
   L = [2, 8, 6, 4]
   i = 0
   while i < len(L):
       if L[i] > 5:
           L.pop(i) # Remove item; DON'T move i forward!
       else:
           i += 1   # Only move forward if we DIDN'T remove anything
   print(L) # [2, 4]
   
   ```

---

## Efficiency: `removeAll(L, v)`

* If you use `while v in L: L.remove(v)`, Python has to search the entire list **twice** for every single removal. 
* For a huge list, this is incredibly slow

The **Efficient Version** only looks at each item exactly once

   ```python
   def removeAll(L, v):
       i = 0 // index variable
       while i < len(L):   //kill switch
           if L[i] == v:   
               L.pop(i)
           else:
               i += 1  //move index foward
   ```
---

### **Checkpoint**

What happens when we run this "slightly broken" version?

```python
def removeAll(L, v):
    i = 0  // index variable
    while i < len(L): //kill switch
        if L[i] == v:
            L.pop(i)
        i += 1  //move index foward

L = [1, 3, 2, 2, 3, 2, 4]
removeAll(L, 2)
print(L)

```

* A. It incorrectly prints `[1, 3, 3]`
* B. It crashes and never prints anything
* C. It incorrectly prints `[1, 3, 2, 3, 4]`
* D. It correctly prints `[1, 3, 3, 4]`

    <details>
    <summary><b>Answer</b></summary>
    <blockquote>
    <b>C. It incorrectly prints <code>[1, 3, 2, 3, 4]</code></b>

    Look at the two <code>2</code>s in the middle. When the code pops the first <code>2</code>, the second <code>2</code> slides into the current index <code>i</code>. But because <code>i += 1</code> happens every time, the loop moves to the next index and <b>skips</b> over that second <code>2</code> entirely!
    </blockquote>
    </details>

---

> [!NOTE]
> **TLDR:** 
> 1. Use `for v in L` for reading.
> 2. Use `while` loops for deleting/modifying.
> 3. If you `pop`, don't increment your index in the same step!

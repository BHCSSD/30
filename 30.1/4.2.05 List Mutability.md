# 4.2.5 List Mutability

## Overview

  * Lists in Python are **mutable**, meaning they can be **changed after creation**
  * Strings are **immutable** (cannot be changed once created)
    
**Key Ideas You Must KNOW:**
* **Mutability**
* **Aliases**
* **Copies**
* **Mutating vs. Non-Mutating Operations**
---

## Lists Are Mutable
* lists can be modified directly.

### String (Immutable Example)
* Strings cannot be changed via index
  ```python
  s = 'abc'
  s[0] = 'd'  # Error: 'str' object does not support item assignment
  ```

### List (Mutable Example)
* Lists CAN be changed via index
  ```python
  L = [1, 3, 5]
  L[0] = 'wow'  # Works â€“ lists are mutable
  print(L)      # ['wow', 3, 5]
  ```

> [!NOTE]
> Assigning a value to `L[i] = "Foo"` **mutates** (changes) the **original list** in place

-----

## Aliases IMPORTANT!!!!!!

* When two variables refer to the **exact same list object** in memory, they are called **aliases**.

  ```python
  L = [1, 3]
  M = L # M is an alias of L; both point to the same memory location
  L[0] = 42
  print(L)  # [42, 3]
  print(M)  # [42, 3]
  print(M is L) # is operator ... they be the same
  ```

* Since they are aliases, a change made via one variable affects the other:

  ```python
  L = [1, 3]
  M = L
  L[0] = 42
  M[1] = 99
  print(L)  # [42, 99]
  print(M)  # [42, 99]
  ```

### Equal but Not Aliases

* Two lists can have the same contents but be distinct objects:
  ```python
  L = [1, 3]
  M = [1, 3]

  print(L == M)  # True (same contents)
  print(L is M)  # False (different objects in memory)
  ```

* In this case, changing one list does **not** affect the other.

-----

## The `is` and `is not` Operators

These operators check for **object identity** (aliasing).

  * `L is M` is True if L and M are **aliases** (refer to the same object).
  * `L is not M` is True if L and M are **different objects**.

    ```python
    L = [1, 3]
    M = L   # Alias
    N = [1, 3] # Separate object

    print(L is M)  # True
    print(L is N)  # False
    print(L == M)  # True
    print(L == N)  # True (same contents)
    ```

* After mutating `L`:

  ```python
  L[0] = 42
  # L is now [42, 3], M is also [42, 3], N is still [1, 3]

  print(L is M)  # True (Still the same object)
  print(L is N)  # False (Still different objects)
  print(L == N)  # False (Contents are now different)
  ```

### Checkpoint

Which of the following is **NOT true**?

* A.  If L is a copy of M, then `L is not M` must be True.
* B.  If `L is M` is True, then `L == M` must be True.
* C.  If `L == M` is True, then `L is M` must be True.
* D.  If L is an alias of M, then `L is M` must be True.

  <details>
  <summary>Answer</summary>
    **NOT true** is **C If `L == M` is True, then `L is M` must be True.**

    * **Why?** `L == M` only means the lists have the same *contents*. As shown with `L = [1, 3]` and `M = [1, 3]`, they can be equal (`== True`) but be two separate objects (`is False`)

  </details>

-----

## Aliases vs. Copies

  * **Aliases** share the same object.
  * **Copies** have the same contents but are separate, distinct objects.
    * they have the same numbers / data inside BUT are not the same place in memory.  

To make a **copy** (called a *shallow copy*):

```python
import copy # Step 1: import the library

L = [1, 3]
M = L         # Alias
N = copy.copy(L) # Copy

print(L is M)  # True (Alias)
print(L is N)  # False (Copy)
print(L == N)  # True (Same contents)
```

  * Changing one copy (`N`) does **not** affect the original list (`L`).

### Checkpoint

```python
L = [1, 2, 3]
M = L
M[2] = 5
print(L, M)
```

1.  What does this code print?

  * A.  `[1, 2, 3], [1, 2, 5]`
  * B.  `[1, 2, 5], [1, 2, 3]`
  * C.  `[1, 2, 5], [1, 2, 5]`
  * D.  `[1, 2, 3], [1, 2, 3]`

    <details>
    <summary>Answer</summary>

    **C. `[1, 2, 5], [1, 2, 5]`**.

      * `M = L` creates an **alias**. When `M[2]` is changed, it mutates the *single list object* in memory that both `L` and `M` point to.

    </details>

---

## Function Parameters Are Aliases

When a list is passed as an argument to a function, the parameter inside the function becomes an **alias** for the original list.

  * If you change the list inside the function, it changes the original list object


    ```python
    def f(M):
        M[0] = 42

    L = [1, 3]
    f(L) # L is passed by reference (aliased)
    print(L)  # [42, 3] (L was mutated by the function)
    ```

The function **does not receive a copy**, it can modify the original

### Checkpoint

Which of the following is true?

* A.  Parameters are copies and not aliases.
* B.  `L + []` creates a copy of L, but using `copy.copy(L)` is preferred.
* C.  You can copy a list however you like.
* D.  A list can be both a copy and an alias at the same time.

  <details>
  <summary>Answer</summary>

  **B. `L + []` creates a copy of L, but using `copy.copy(L)` is preferred.**

    * A. is False (Parameters are aliases)
    * C. is False (While many ways exist, `copy.copy()` is the standard and most explicit way, and some methods like `c = a[:]` are just shallow copies)
    * D. is False (An object is either an alias/reference or a copy/separate object)

  </details>

-----

## Mutating vs. Non-Mutating Operations

  * **Mutating** operations **change** the list object in place
  * **Non-Mutating** operations **create a new list** (leaving the original untouched)

### Non-Mutating Example (Creates New List)

* The standard multiplication operator (`*`) creates a new list

  ```python
  L = ['a', 'b']
  M = L
  L = L * 2 # L now refers to a new list object

  print(L is M)  # False (L now points to a new list)
  print(L)       # ['a', 'b', 'a', 'b']
  print(M)       # ['a', 'b']
  ```

### Mutating Example (Modifies in Place)

* The augmented assignment operator (`*=`) usually mutates the list

  ```python
  L = ['a', 'b']
  M = L
  L *= 2 # Mutates the list L and M are pointing to

  print(L is M)  # True (L and M still point to the same object)
  print(L)       # ['a', 'b', 'a', 'b']
  print(M)       # ['a', 'b', 'a', 'b']
  ```

### Patterns to Remember

| Type | Examples | Behavior | Return Value |
| :--- | :--- | :--- | :--- |
| **Mutating** | `*=`, `+=`, `.sort()`, `.reverse()`, `.append()` | Changes **original** list | Usually `None` |
| **Non-Mutating** | `*`, `+`, `sorted()`, `reversed()`, `list(L)` | Creates **new** list/sequence | Returns the new value |

### Checkpoint

Which of the following is **NOT** a correct Python pattern?

* A.  Functions like `sorted(L)` and `reversed(L)` are non-mutating
* B.  Assignment operators like `*=` and `+=` are mutating
* C.  Non-assignment operators like `*` and `+` are non-mutating
* D.  Methods like `.sort()` and `.reverse()` are mutating
* E.  Non-mutating methods return `None`

  <details>
  <summary>Answer</summary>

   **E. Non-mutating methods return `None`.**

    * **Why?** Non-mutating operations return a **new value** (like a new list or sorted sequence) because they don't modify the original. It is the **mutating methods** (like `.sort()` or `.append()`) that typically return `None`.

  </details>

